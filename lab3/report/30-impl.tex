\chapter{Технологическая часть}

В данном разделе производится выбор средств реализации, а также приводятся требования к программному обеспечению (ПО), листинги реализованных алгоритмов и тесты для программы.

\section{Требования к ПО}

На вход программе подается массив целых чисел, а на выходе должен быть получен масссив, отсортированный с помощью каждого реализованного алгоритма сортировки: вставками, пузырьком и шейкерной. Также необходимо вывести затраченное каждым алгоритмом процессорное время.

\section{Выбор средств реализации}

В качестве языка программирования для реализации данной лабораторной работы был выбран язык Python  \cite{PythonBook}. Он позволяет быстро реализовывать различные алгоритмы без выделения большого времени на проектирование сруктуры программы и выбор типов данных. 

Кроме того, в Python есть библиотека time, которая предоставляет функцию process\_time для замера процессорного времени \cite{process_time_text}.

В качестве среды разработки выбран PyCharm. Он является кросс-платформенным, а также предоставляет удобный и функциональнаый отладчик и средства для рефакторинга кода, что позволяет быстро находить и исправлять ошибки \cite{pycharm}.

\section{Листинги кода}

В листингах \ref{insertion_list} - \ref{shaker_list} представлены реализации рассматриваемых алгоритмов.

\begin{lstlisting}[caption=Реализация алгоритма сортировки вставками,
	label={insertion_list}]
	def insertion_sort(arr, n):
		for i in range(1, n):
			j = i
			cur = arr[j]
			while arr[j - 1] > cur and j > 0:
				arr[j] = arr[j - 1]
				j -= 1
			arr[j] = cur
		return arr
\end{lstlisting}


\begin{lstlisting}[caption=Реализация алгоритма сортировки пузырьком,
	label={bubble_list}]
	def bubble_sort(arr, n):
		for i in range(n - 1):
			for j in range(n - i - 1):
				if arr[j] > arr[j + 1]:
					arr[j], arr[j + 1] = arr[j + 1], arr[j]
		return arr
\end{lstlisting}

\begin{lstlisting}[caption=Реализация алгоритма шейкерной сортировки,
	label={shaker_sort}]

	def shaker_sort(arr, n):
		left = 0
		right = n - 1
		while left <= right:
			for i in range(right, left, -1):
				if arr[i - 1] > arr[i]:
					arr[i - 1], arr[i] = arr[i], arr[i - 1]
			left += 1
			for i in range(left, right, 1):
				if arr[i] > arr[i + 1]:
					arr[i + 1], arr[i] = arr[i], arr[i + 1]
			right -= 1
		
		return arr
\end{lstlisting}

\section{Тестирование}

В таблице \ref{test} приведены функциональные тесты для алгоритмов сортировок. Все тесты пройдены успешно каждой реализацией.

\begin{table}[h]
	\begin{center}
		\caption{\label{test} Тесты}
		\begin{tabular}{|c|c|c|c|}
			\hline
			&                    & \multicolumn{2}{c|}{\bfseries Ожидаемый результат}    \\ \cline{2-3-4}\hline
			Массив & i & РЛ & РДЛ \\ [0.5ex] 
			\hline
			 &  & 0 & 0\\
			\hline
			abc & abc & 0 & 0\\
			\hline
			ab & a & 1 & 1\\
			\hline
			a & ab & 1 & 1\\
			\hline
			see & sea & 1 & 1\\
			\hline
			1234 & 1324 & 2 & 1\\
			\hline
			hello & ehlla & 3 & 2\\
			\hline
			cat & pop & 3 & 3\\
			\hline
			кот & скат & 2 & 2\\
			\hline
		\end{tabular}
	\end{center}
\end{table}


\section*{Вывод}

Был производен выбор средств реализации, реализованы и протестированы алгоритмы поиска расстояний: Левенштейна - итерационный и рекурсивный (с кешем и без), Дамерау-Левенштейна - рекурсивный без кеша
