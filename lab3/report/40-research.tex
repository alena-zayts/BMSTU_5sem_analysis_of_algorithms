\chapter{Исследовательская часть}

\section{Пример работы}

На рисунке \ref{img:work_example} приведен пример работы программы.

\boximg{160mm}{work_example}{Пример работы программы}

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item операционная система: Windows 10;
	\item оперативная память: 16 Гб;
	\item процессор: Intel® Core™ i5-8259U.
\end{itemize}

Во время тестирования ноутбук был включен в сеть питания и нагружен только встроенными приложениями окружения и системой тестирования.


\section{Сравнение времени выполнения реализаций алгоритмов}

 Все реализации алгоритмов сравнивались на трех видах массивов: упорядоченный (лучший случай - все реализации выдают наименьшее время работы), упорядоченный в обратном порядке (худший случай - все реализации выдают наибольшее время работы), случайно сгенерированный массив (произвольный случай). При этом для каждого класса массивов создавались массивы длиной от 0 до 10000 с шагом, увеличивающимся по мере роста длины массива. 
 
 Так как сортировки выполняются достаточно быстро, а замеры времени имеют некоторую погрешность, они для каждых класса и длины массивы и каждой реализации алгоритма сортировки выполнялись 10 раз, а затем вычислялось среднее время работы.
 
 
На рисунке \ref{img:time_all} приведены результаты сравнения времени работы всех реализаций на всех массивах. 

\img{120mm}{time_all}{Сравнение времени работы реализаций всех алгоритмов на всех массивах}



На рисунках \ref{img:time_best} - \ref{img:time_middle} приведены результаты сравнения времени работы всех реализаций на отдельных классах массивов.

\img{100mm}{time_best}{Сравнение времени работы реализаций всех алгоритмов на упорядоченных массивах}

\img{100mm}{time_worst}{Сравнение времени работы реализаций всех алгоритмов на упорядоченных в обратном порядке массивах}

\img{100mm}{time_middle}{Сравнение времени работы реализаций всех алгоритмов на произвольных массивах}



На рисунках \ref{img:time_insertion} - \ref{img:time_shaker} приведены результаты сравнения времени работы каждой реализации на всех классах массивов.

\img{100mm}{time_insertion}{Сравнение времени работы реализации алгоритма сортировки вставками на всех классах массивов}

\img{100mm}{time_bubble}{Сравнение времени работы реализации алгоритма сортировки пузырьком на всех классах массивов}

\img{100mm}{time_shaker}{Сравнение времени работы реализации алгоритма шейкерной сортировки на всех классах массивов}



\section{Сравнение трудоемкости реализаций алгоритмов}

Введем модель вычисления трудоемкости для оценки алгоритмов: 
\begin{itemize}
	\item базовые операции стоимостью 1: -, --, -=, +, ++, +=, ==, !=, <, >, <=, >=, >>, <<, [];
	\item базовые операции стоимостью 2: *, *=, /, /=, \%, \%=;
	\item оценка трудоемкости цикла: Fц = Finit + Fсравн + N * (Fтела + Finc + Fсравн), где Finit, Fсравн, Fтела, Finc - трудоемкости инициализации,  проверки условия цикла, инкрементирования и тела цикла, соответственно, а N - количество итераций;
	\item стоимость условного оператроа: Fуо = Fсравн + 
	\begin{equation}
		+
		\left[ 
		\begin{array}{c} 
			min(f1, f2) \\
			max(f1, f2)\\
		\end{array}
		\right.,\\
	\end{equation}где Fсравн, f1, f2 - трудоемкости проверки условия, первого блока и второго блока, соответственно.
	
\end{itemize}

Оценим трудоемкость реализаций алгоритмов сортировки.

Рассмотрим трудоемкость реализации алгоритма сортировки вставками.

Лучший случай (отсортированный массив): алгоритм ни разу не войдет во внутренний цикл. Трудоемкость: $f(n) = 2 + (n - 1)(2 + 1 + 2 + 4 + 2) =  11n - 9 = O(n)$.

Худший случай (отсортированный в обратном порядке массив): алгоритм будет полностью (пока не дойдет до начала массива) проходить внутренний цикл каждый раз . Трудоемкость: $f(n) = 2 + (n - 1)(2 + 1 + 2 + 4 + 2 + \frac{n}{2} (4 + 4 + 1)) =  \frac{9n^2}{2} + \frac{13n}{2} - 9 = O(n^2)$.


Рассмотрим трудоемкость алгоритма сортировки пузырьком.

Лучший случай (отсортированный массив): не будет произведено ни одного обмена. Трудоемкость: $f(n) = 3 + (n - 1)(3 + \frac{n}{2} 4) = 2n^2 + n = O(n^2)$.

Худший случай (отсортированный в обратном порядке массив): замена во внутреннем цикле будет производиться каждый раз. Трудоемкость: $f(n) = 3 + (n - 1)(3 + \frac{n}{2} (4 + 9) = \frac{13n^2}{2} - \frac{7n}{2} = O(n^2)$.



\section*{Вывод}

Реализация сортировки пузырьком квадратично зависит от количества элементов в массиве (как в лучшем, так и в худшем случае) и работает дольше всех остальных протестированных реализаций. Ее модификация - шейкерная сортировка - показывает схожие результаты, так как является модификацией только лишь по направлению движения. 

Реализацией, которая работает меньшее количество времени, чем вышеупомянутые, является реализация алгоритма сортирвки вставками. Для нее в худшем случае время сортировки массива также квадратично зависит от количества элементов в нем, как и для алгоритмов пузырьковой и шейкерной сортировки. Но для лучшего случая время работы реализации алгоритма сортирвки вставками зависит от количества элементов линейно.

Таким образом, реализацией с наименьшим временем выполнения (по экспериментальным данным - во всех случаях) является сортировка вставками.
