\chapter{Исследовательская часть}

\section{Пример работы}

На рисунке \ref{img:work_example} приведен пример работы программы.

\boximg{160mm}{work_example}{Пример работы программы}

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item операционная система: Windows 10;
	\item оперативная память: 16 Гб;
	\item процессор: Intel® Core™ i5-8259U.
\end{itemize}

Во время тестирования ноутбук был включен в сеть питания и нагружен только встроенными приложениями окружения и системой тестирования.

\section{Время выполнения алгоритмов}

 Все реализованные алгоритмы сравнивались на случайно сгенерированных строках длиной от 0 до 10 с шагом 1, а те, что используют матрицы расстояний, еще и на строках длиной от 20 до 100 с шагом 10. Замеры времени для каждой длины строк и каждого алгоритма производились 10 раз, а затем вычислялось среднее время работы алгоритма со строкой.
 
На рисунке \ref{img:time_all} приведены результаты сравнения времени работы всех реализованных алгоритмов. Как видно на графике, алгоритмы, использующие матрицы рассотяний, работают значительно быстрее рекурсивных алгоритмов без кеширования. Это обусловлено отсутвием в первых вызова функций для вычисления значений, которые уже были подсчитаны ранее.

\img{120mm}{time_all}{Сравнение времени работы алгоритмов}

 Чтобы получить полную картину, сравним отдельно алгоритмы, использующие матрицы рассотяний, и те, которые их не используют.
 
 На рисунке \ref{img:time_with_matrix} приведено сравнение времени выполнения реализаций итерационного и рекурсивного (с кешированием) алгоритмов поика расстояния Левенштейна. Как видно, время их работы растет соизмеримо, что обусловлено их схожестью в отсутствии вызова функций для вычисления значений, которые уже были подсчитаны ранее. Однако второй алгоритм все же работает дольше, так как в нем тратится время на рекурсивный вызов самого себя. 
 
 \img{120mm}{time_with_matrix}{Сравнение времени работы рекурсивных алгоритмов, использующих матрицы растояний}
 
 На рисунке \ref{img:time_rec_without_cash} приведено сравнение времени выполнения реализаций рекурсивных алгоритмов (без кеширования) поика расстояний Левенштейна и Дамерау-Левенштейна. Эти алгоритмы работали примерно одинаковое количество времени, однако алгоритм Дамерау-Левенштейна - немного дольше, так как ему требуется время на подсчет штрафа для дополнительной операции - обмена местами соседних символов.
 
 
 \img{120mm}{time_rec_without_cash}{Сравнение времени работы рекурсивных алгоритмов, не использующих кеш}
 
 
 %Однако если специально подавать им такие строки, в которых возможна операция обмена соседних символов местами, то алгоритм Дамерау-Левенштейна будет работать дольше, так как ему потребуется время на подсчет штрафа для этой дополнительной операции. Это явление продемонстрировано на рисунке \ref{img:time_dl}. Алгоритмам подавались такие строки: в первой строке n раз повторяется комбинация 'ab', а во второй - n раз 'ba', где n принимает целые значения от 0 до 5.

%\img{120mm}{time_dl}{Сравнение времени работы рекурсивных алгоритмов, не использующих кеш, при особых строках}



\section{Пиковая требуемая алгоритмами память}

Алгоритмы нахождения расстояний Левенштейна и Дамерау—Левенштейна имеют одинаковый подход к использованию памяти. Следовательно, достаточно сравнить, как с увеличением длин строк изменяется пиковая затрачиваемая память в рекурсивных и итерационных реализациях этих алгоритмов. 

При использовании рекурсивной реализации без кеширования для каждого рекурсивного вызова функции будет необходимо выделять память под локальные переменные, возвращаемое функцией значение, адрес возврата. Максимальная глубина стека вызовов равна сумме длин исходных строк. Следовательно, пиковая затрачиваемая память растет пропорционально сумме длин строк. 

При использовании итерационного алгоритма память в большей степени затрачивается на матрицу расстояний размером  len($S_{1}$) на len($S_{2}$). Следовательно, пиковая затрачиваемая память растет пропорционально произведению длин строк, что больше, чем при рекурсивной реализации.

Однако итерационный алгоритм можно оптимизировать по памяти, храня лишь последние две строки матрицы расстояний, и тогда пиковая затрачиваемая память будет расти пропорционально изменению длины одной из строк, что меньше, чем при рекурсивной реализации.

Рекурсивные функции с кешированием по этому показателю - худший вариант, так как они потребуют память как под матрицу расстояний (хотя бы в одном экземпляре), так и под стек вызовов.

При небольших длинах строк затрачиваемая память сильно зависит от самой реализации каждого алгоритма (количество локальных переменных, подходы к хранению строк и матриц)

\section*{Вывод}

Алгоритм нахождения расстояния Дамерау — Левенштейна по времени выполнения сопоставим с алгоритмом нахождения расстояния Левенштейна, хотя и немного уступает второму в связи с дополнительной проверкой, позволяющей находить ошибки пользователя, связанные с неверным порядком букв. Однако эта операция зачастую позволяет найти более короткое расстояние между строками.

Рекурсивные алгоритмы нахождения расстояний Левенштейна и Дамерау-Левенштейна, не использующие кеширование, работают на порядок дольше итеративных реализаций. При применении кеширования они требуют меньше времени, однако все равно уступают по производительности итеративным алгоритмам, особенно при большой длине строк. 

Но по расходу памяти итеративные алгоритмы проигрывают рекурсивным: максимальный размер используемой памяти в них пропорционален произведению длин строк, в то время как в рекурсивных алгоритмах — сумме длин строк.

Если же применить к итеративным алгоритмам оптимизацию по памяти, то они будут выигрывать как по пиковой затрачиваемой памяти, так и по времени выполнения.
