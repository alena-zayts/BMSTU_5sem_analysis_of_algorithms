\chapter{Исследовательская часть}

\section{Пример работы}

На рисунке \ref{img:work_example} приведен пример работы программы.

\boximg{160mm}{work_example}{Пример работы программы}

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item операционная система: Windows 10;
	\item оперативная память: 16 Гб;
	\item процессор: Intel® Core™ i5-8259U.
\end{itemize}

Во время тестирования ноутбук был включен в сеть питания и нагружен только встроенными приложениями окружения и системой тестирования.


\section{Сравнение трудоемкости реализаций алгоритмов}
допишем


\section{Сравнение времени выполнения реализаций алгоритмов}

 Все реализации алгоритмов сравнивались на трех видах массивов: упорядоченный (лучший случай - все реализации выдают наименьшее время работы), упорядоченный в обратном порядке (худший случай - все реализации выдают наибольшее время работы), случайно сгенерированный массив (произвольный случай). При этом для каждого класса массивов создавались массивы длиной от 0 до 10000 с шагом, увеличивающимся по мере роста длины массива. 
 
 Так как сортировки выполняются достаточно быстро, а замеры времени имеют некоторую погрешность, они для каждых класса и длины массивы и каждой реализации алгоритма сортировки выполнялись 10 раз, а затем вычислялось среднее время работы.
 
 
На рисунке \ref{img:time_all} приведены результаты сравнения времени работы всех реализаций на всех массивах. 

\img{120mm}{time_all}{Сравнение времени работы реализаций всех алгоритмов на всех массивах}



На рисунках \ref{img:time_best} - \ref{img:time_middle} приведены результаты сравнения времени работы всех реализаций на отдельных классах массивов.

\img{100mm}{time_best}{Сравнение времени работы реализаций всех алгоритмов на упорядоченных массивах}

\img{100mm}{time_worst}{Сравнение времени работы реализаций всех алгоритмов на упорядоченных в обратном порядке массивах}

\img{100mm}{time_middle}{Сравнение времени работы реализаций всех алгоритмов на произвольных массивах}



На рисунках \ref{img:time_insertion} - \ref{img:time_shaker} приведены результаты сравнения времени работы каждой реализации на всех классах массивов.

\img{100mm}{time_insertion}{Сравнение времени работы реализации алгоритма сортировки вставками на всех классах массивов}

\img{100mm}{time_bubble}{Сравнение времени работы реализации алгоритма сортировки пузырьком на всех классах массивов}

\img{100mm}{time_shaker}{Сравнение времени работы реализации алгоритма шейкерной сортировки на всех классах массивов}


\section*{Вывод}

Реализации алгоритмов нахождения расстояния Дамерау — Левенштейна по времени выполнения сопоставимы с реализациями алгоритмом нахождения расстояния Левенштейна, хотя и немного уступают вторым в связи с дополнительной проверкой, позволяющей находить ошибки пользователя, связанные с неверным порядком букв. Однако эта операция зачастую позволяет найти более короткое расстояние между строками.

Рекурсивные реализации алгоритмов нахождения расстояний Левенштейна и Дамерау-Левенштейна, не использующие кеширование, работают на порядок дольше итеративных реализаций. При применении кеширования они требуют меньше времени, однако все равно уступают по производительности итеративным алгоритмам, особенно при большой длине строк. 

Но по расходу памяти итеративные реализации проигрывают рекурсивным: максимальный размер используемой памяти в них пропорционален произведению длин строк, в то время как в рекурсивных — сумме длин строк.

Если же применить к итеративным реализациям оптимизацию по памяти, то они будут выигрывать как по пиковой затрачиваемой памяти, так и по времени выполнения.
